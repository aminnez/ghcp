import 'dart:convert';

import 'package:ghcp/exceptions.dart';
import 'package:ghcp/github/github_api_client.dart';
import 'package:ghcp/github/models/github_content.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:test/test.dart';

// This file is generated by build_runner, run `dart run build_runner build` to generate mocks
@GenerateMocks([http.Client])
import 'github_api_client_test.mocks.dart';

void main() {
  late MockClient mockHttpClient;
  late GitHubApiClient gitHubApiClient;
  const testToken = 'test_token';

  setUp(() {
    mockHttpClient = MockClient();
    gitHubApiClient = GitHubApiClient(
      httpClient: mockHttpClient,
      token: testToken,
    );
  });

  tearDown(() {
    gitHubApiClient.dispose();
  });

  group('getContents', () {
    const testPath = 'https://api.github.com/repos/owner/repo/contents';
    final testJsonResponse = [
      {
        'name': 'file1.txt',
        'path': 'file1.txt',
        'type': 'file',
        'download_url': 'https://example.com/file1.txt',
        'size': 10,
        'url': 'https://api.github.com/repos/owner/repo/contents/file1.txt',
      },
      {
        'name': 'dir1',
        'path': 'dir1',
        'type': 'dir',
        'url': 'https://api.github.com/repos/owner/repo/contents/dir1',
        'size': 0,
        'download_url': null,
      },
    ];

    test('returns list of GitHubContent for valid response', () async {
      // Arrange
      when(
        mockHttpClient.get(Uri.parse(testPath), headers: anyNamed('headers')),
      ).thenAnswer(
        (_) async => http.Response(
          jsonEncode(testJsonResponse),
          200,
          headers: {'content-type': 'application/json'},
        ),
      );

      // Arrange - Nested directory call
      final nestedDirResponse = [
        {
          'name': 'nested_file.txt',
          'path': 'dir1/nested_file.txt',
          'type': 'file',
          'download_url': 'https://example.com/dir1/nested_file.txt',
          'size': 10,
          'url':
              'https://api.github.com/repos/owner/repo/contents/dir1/nested_file.txt',
        },
      ];

      // Mock the directory content request
      when(
        mockHttpClient.get(
          Uri.parse('https://api.github.com/repos/owner/repo/contents/dir1'),
          headers: anyNamed('headers'),
        ),
      ).thenAnswer(
        (_) async => http.Response(
          jsonEncode(nestedDirResponse),
          200,
          headers: {'content-type': 'application/json'},
        ),
      );

      // Act
      final result = await gitHubApiClient.getContents(testPath);

      // Assert
      expect(result, isA<List<GitHubContent>>());
      expect(result.length, 2);
      expect(result[0].name, 'file1.txt');
      expect(result[1].name, 'dir1/nested_file.txt');
    });

    test('includes authorization header when token is provided', () async {
      // Arrange
      when(
        mockHttpClient.get(Uri.parse(testPath), headers: anyNamed('headers')),
      ).thenAnswer((_) async => http.Response(jsonEncode([]), 200));

      // Act
      await gitHubApiClient.getContents(testPath);

      // Assert
      final captured = verify(
        mockHttpClient.get(
          Uri.parse(testPath),
          headers: captureAnyNamed('headers'),
        ),
      ).captured;

      final headers = captured[0] as Map<String, String>;
      expect(headers['Authorization'], 'Bearer $testToken');
      expect(headers['Accept'], 'application/vnd.github+json');
    });

    test('throws GitHubApiException on non-200 status code', () async {
      // Arrange
      when(
        mockHttpClient.get(Uri.parse(testPath), headers: anyNamed('headers')),
      ).thenAnswer((_) async => http.Response('Not Found', 404));

      // Act & Assert
      expect(
        () => gitHubApiClient.getContents(testPath),
        throwsA(
          isA<GitHubApiException>().having(
            (e) => e.statusCode,
            'statusCode',
            404,
          ),
        ),
      );
    });

    test('recursively processes directory contents', () async {
      // Arrange - First call (root directory)
      when(
        mockHttpClient.get(Uri.parse(testPath), headers: anyNamed('headers')),
      ).thenAnswer(
        (_) async => http.Response(
          jsonEncode(testJsonResponse),
          200,
          headers: {'content-type': 'application/json'},
        ),
      );

      // Arrange - Nested directory call
      final nestedDirResponse = [
        {
          'name': 'nested_file.txt',
          'path': 'dir1/nested_file.txt',
          'type': 'file',
          'download_url': 'https://example.com/dir1/nested_file.txt',
          'size': 10,
          'url':
              'https://api.github.com/repos/owner/repo/contents/dir1/nested_file.txt',
        },
      ];

      // Mock the directory content request
      when(
        mockHttpClient.get(
          Uri.parse('https://api.github.com/repos/owner/repo/contents/dir1'),
          headers: anyNamed('headers'),
        ),
      ).thenAnswer(
        (_) async => http.Response(
          jsonEncode(nestedDirResponse),
          200,
          headers: {'content-type': 'application/json'},
        ),
      );

      // Act
      final result = await gitHubApiClient.getContents(testPath);

      // Assert
      expect(result, hasLength(2));
      expect(result[1].name, 'dir1/nested_file.txt');

      // Verify the directory request was made
      verify(
        mockHttpClient.get(
          Uri.parse('https://api.github.com/repos/owner/repo/contents/dir1'),
          headers: {
            'Accept': 'application/vnd.github+json',
            'Authorization': 'Bearer $testToken',
          },
        ),
      ).called(1);
    });
  });

  group('downloadFile', () {
    const testUrl =
        'https://raw.githubusercontent.com/owner/repo/main/file.txt';
    const testContent = 'test file content';

    test('returns file content as bytes for successful download', () async {
      // Arrange
      when(
        mockHttpClient.get(Uri.parse(testUrl), headers: anyNamed('headers')),
      ).thenAnswer((_) async => http.Response(testContent, 200));

      // Act
      final result = await gitHubApiClient.downloadFile(testUrl);

      // Assert
      expect(result, equals(utf8.encode(testContent)));
    });

    test('includes authorization header when token is provided', () async {
      // Arrange
      when(
        mockHttpClient.get(Uri.parse(testUrl), headers: anyNamed('headers')),
      ).thenAnswer((_) async => http.Response('', 200));

      // Act
      await gitHubApiClient.downloadFile(testUrl);

      // Assert
      final captured = verify(
        mockHttpClient.get(
          Uri.parse(testUrl),
          headers: captureAnyNamed('headers'),
        ),
      ).captured;

      final headers = captured[0] as Map<String, String>;
      expect(headers['Authorization'], 'Bearer $testToken');
    });

    test('throws GitHubApiException on non-200 status code', () async {
      // Arrange
      when(
        mockHttpClient.get(Uri.parse(testUrl), headers: anyNamed('headers')),
      ).thenAnswer((_) async => http.Response('Not Found', 404));

      // Act & Assert
      expect(
        () => gitHubApiClient.downloadFile(testUrl),
        throwsA(
          isA<GitHubApiException>().having(
            (e) => e.statusCode,
            'statusCode',
            404,
          ),
        ),
      );
    });
  });

  group('dispose', () {
    test('closes the underlying http client', () {
      // Act
      gitHubApiClient.dispose();

      // Assert
      verify(mockHttpClient.close());
    });
  });
}
